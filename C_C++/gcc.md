gcc/g++

## 一、gcc　VS　g++

### gcc

```
cc = gcc      // gcc支持多种编程语言的编译器；
gcc -c main.c  -o main.o          //main.o编译生成的目标文件；
或 gcc -c main.c     ///生成目标文件 main.o;

gcc hello.c -o hello //生成可执行文件
gcc hello1.c hello2.cpp -o c(或makefile) //编译多个cpp为可执行文件

```

#### ps：关于gcc编译c的过程

```

1. 源代码编译预处理：在预处理过程中，对源代码文件中的文件包含(include)、预编译语句(如宏定义define等)进行分析。
gcc -E hello.c -o hello.i

2. 经过编译器，生成汇编代码：
gcc -S hello.i -o hello.s

3. 经过汇编器，生成目标代码：
gcc -c hello.s -o hello.o

4. 经过链接器（负责将程序的目标文件与所需的所有附加的目标文件连接起来，附加的目标文件包括静态连接库和动态连接库），生成可执行程序；在链接阶段，所有的目标文件被安排在可执行程序中的恰当的位置，同时，该程序所调用到的库函数也从各自所在的档案库中连到合适的地方。
gcc hello.o -o hello

5. 运行可执行文件：
./hello

6. 上述步骤可以放在一起执行，gcc内部自动进行一系列处理：
gcc hello.c -o hello

./hello
```



```
gcc [选项]  [文件名]

选项包括：

假设源程序文件名为test.c

1. 无选项编译链接
用法：#gcc test.c
作用：将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。

2. 选项 -o
用法：#gcc test.c -o test
作用：将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。

3. 选项 -E
用法：#gcc -E test.c -o test.i
作用：将test.c预处理输出test.i文件。

4. 选项 -S
用法：#gcc -S test.i
作用：将预处理输出文件test.i汇编成test.s文件。

5. 选项 -c
用法：#gcc -c test.s
作用：将汇编输出文件test.s编译输出test.o文件。

6. 无选项链接
用法：#gcc test.o -o test
作用：将编译输出文件test.o链接成最终可执行文件test。

7. 选项-O
用法：#gcc -O1 test.c -o test
作用：使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。

8.-Wall选项：使gcc产生尽可能多的警告信息，警告信息很有可能是错误的来源，特别是隐式编程错误，所以尽量保持0 warning。

一些关于头文件库文件目录的选项如下：

-I 选项（大写的 i）：向头文件搜索目录中添加新的目录。
1、用＃include"file"的时候,gcc/g++会先在当前目录查找你所制定的头文件,如
果没有找到,他回到缺省的头文件目录找。
如果使用-I制定了目录,他会先在你所制定的目录查找,然后再按常规的顺序去找.
2、用＃include<file>,gcc/g++会到-I制定的目录查找,查找不到,然后将到系统的缺
省的头文件目录查找.
例如：
gcc –I /usr/dev/mysql/include test.c –o test.o

-L选项说明库文件所在的路径。
例如：-L.（“.”表示当前路径）。
      -L/usr/lib （“/usr/lib” 为路径。注：这里的路径是绝对路径）
如果没有提供 -L选项，gcc 将在默认库文件路径下搜索.

-l选项（小写的 l）说明库文件的名字。如果库文件为 libtest.so， 则选项为： -ltest

-static 强制使用静态库编译，相当于进行静态编译，生成可执行文件会大一些，但是不需要再额外添加库，往板子上移植的时候比较方便，需要注意的是自己添加库文件路径，库文件名字需要正确，会比较困扰。

```



### g++

```
g++ a.cpp   ///生成可执行文件a.out;
g++ a.cpp -o test   ///生成可执行文件test;
g++ -c a.cpp    ////生成目标文件a.o;
g++ a.o    ///生成可执行文件a.out;
g++ -c a.cpp -o t  ////生成目标文件t;
g++ hello1.cpp hello2.cpp -o hello（或makefile） ///编译多个cpp生成可执行文件hello
```



## 二、编辑器　VS　编译器

### 编译器的工作流程：

![img](http://upload-images.jianshu.io/upload_images/2558748-06eebaf3fd949628.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

编辑器是用来编写程序源文件的软件程序。常见的编辑器有文本编辑器、网页编辑器、源程序编辑器、图像编辑器，声音编辑器和视频编辑器等。编译器将程序源文件转换成计算机能识别的二进制文件即目标文件。链接器将编译器产生的目标二进制文件和相关联的库二进制文件链接起来融合成一个可执行程序。

集成开发环境整合了编辑器、编译器、链接器，调试，部署，乃至代码版本管理等功能于一体，为了方便程序员编写，编译，调试和部署程序。

### 编译型语言和解释型语言

高级语言又分编译型语言（C、C++、Pascal（Delphi）等）和解释型语言（JAVA、JavaScript、PHP等），虽然最终都需要编译成机器语言才能被计算机识别和执行但是——

- 编译型语言需要将源码一并地转换成机器语言的程序之后再执行，针对不同计算机结构编译后的机器语言无法跨平台运行；
- 解释型语言是在运行的时候将程序先编译成字节码（可以理解为一个中间语言），再在运行的时候由运载解释型语言的环境将字节码翻译成机器语言。但这个过程中可以依靠运载环境根据不同的计算机硬件结构生成相应的机器语言，从而具有跨平台的特性。

 **机器语言**（机器码）是用二进制代码（只包含“0”和“1”的代码）表示的、计算机能直接识别和执行的一种机器指令的集合。汇编语言（符号语言）是将二进制的机器码通过助记符的方式让人可以更方便地编写并检查的低级语言。汇编语言接近机器语言，可以看做是机器语言的另一种形式，计算机在运行时也需要将汇编语言变为机器语言的二进制形式才可运行，这两种语言都是面向机器的语言，和具体机器的指令系统密切相关。

 

 

 

 